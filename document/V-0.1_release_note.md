# 2022-05-07 ~ 2022-05-09

- 初始化项目，构建omega父工程及omega-core模块。

- 编写第一个注解@Component，此注解参照Spring的@Component注解，通过此注解告知omega容器该类为待托管的类

- 编写基于Java包路径的类扫描逻辑

  - 基于ClassLoader进行当前JVM上下文指定basePackage的URL扫描
  - 根据jar和file两种类型，遍历其包及子包路径下的Class文件
  - 载入Class文件
  - 过滤未使用@Component注解的Class

# 2022-05-09
借鉴Spring框架， 在原有Component注解的基础之上，扩展Service注解。
  
Spring在处理的时候，使用了注解的注解，即@Service注解使用了@Component注解，
同时在扫描的过程中，对注解的注解进行递归，进而判断该类是否需要由容器管理。

这种方式需要扩展扫描器的判断逻辑，同时需要注意一些问题
1. 需要过滤掉java包自身的几个注解，因为他们存在了相互使用或自身使用。直接递归会导致栈溢出问题，如@Documented代码
  ``` java
  @Documented
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.ANNOTATION_TYPE)
  public @interface Documented {
  }
  ```
2. 仅过滤java包，仍然会存在潜在风险。
   因为我们的目标是像Spring框架一样，可以做为第三方工具框架被使用，
   所以如果最终用户编写了自定义注解，且这些注解间也存在了互相使用的问题，依然会导致栈溢出。
3. 但如果将注解的扫描范围限在```com.mostaron.core.annotation```，则会严重限制代码的可扩展性。
   且如果用户将自定义注解也写在这个包下同时互相使用，仍然会重复问题2的结果。
4. 基于这些原因，在进行递归的过程中，加入递归深度计数器，暂定递归深度为**5**，超过将不再继续递归，而是直接返回否。

## 残留问题
目前只判断了类是否被@Component注解及其子注解标记，
但使用@Component的子注解并未将其Meta信息传递或标记出来，
这将导致通过Component的子注解筛选出来的对象，无法找到对应的Component注解，并进行相关处理。

Spring使用的方法为建立了一整套的MergedAnnotation处理方案，将多个不同的注解进行了合并，
同时使用MetadataReader进行相关的属性读取处理。

因此需要对isComponent方法再次重构，在判断是否被Component的最终子注解标记的同时，还需要记录该注解，
这样在后续的缓存Bean构建时，才可以根据这些配置信息进行自定义的处理。

# 2022-05-11
鉴于之前的残留问题，参考BeanDefinition的实现，编写Bean的定义类，存储Metadata等相关信息。

在初期扫描的过程中，将除java包下的其它Annotation依次添加至一个对应的ArrayList，以备后续使用。
同时还需要考虑多级Annotation的属性合并操作。

编写BeanDefinition对象，保存被托管Class的定义，包含Class名称、Class对象、注解列表等信息。
在遍历判断某个类是否为被托管对象时，同时计算其注解列表并处理。

在计算注解列表时，会逐级获取注解中包含@ApplyTo的属性，并将这些属性写回父级注解中。

## 注解属性合并处理

在递归遍历注解列表时，会生成一个默认的属性池，属性池的数据结构如下：
``` java
 Map<Class<? extends Annotation>, Map<String, Object>> metadataBox
```
该常量池的Key为被```@ApplyTo```注解标过的父级注解，Value为子注解中配置的属性名及值的Map集合。
属性合并遵循以下操作逻辑
1. 判断属性池中是否存在当前注解的属性，若存在则覆盖之。
    ```
    由于在JVM中，注解会被处理为代理类，所以需要通过代理来获取JVM中注解对应的代理对象InvocationHandler，
    在InvocationHandler中，使用了Map对象memberValues保存了原注解类定义的属性及其值。
    所以属性的覆盖，本质上就是对该Map的覆盖。
   
    JVM中注解的代理InvocationHandler对象最终被sun.reflect.annotation.AnnotationInvocationHandler来实现。
    由于本项目开发时基于JDK17，而在当前版本中，由于模块化的问题，会导致系统没有权限反射至sun.reflect包中，所以需要在启动时添加如下JVM参数：
    --add-opens java.base/sun.reflect.annotation=ALL-UNNAMED
   
    对于这个问题，后期将考虑将本项目升级为支持模块化。
    ```
2. 遍历当前注解中是否存在使用了```@ApplyTo```注解的属性，若存在则将其合并至属性池。

    1. 遍历当前注解Class包含的Method
    2. 将Method对象包装为MergeInfo对象
    3. 过滤出未使用```@ApplyTo```注解的Method
    4. 判断属性池是是否已经包含```@ApplyTo```注解标识的父注解及其属性的键值对
    5. 在递归的过程中，是由子级逐渐向父级递归，若已存在属性配置，表示在上级时已经处理过，优先级要高于当前注解，故不再处理
    6. 若不存在，同将其合并至属性池

至此，BeanDefinition的初步创建已经完成。

下一步将处理Bean初始化的过程，在未实现AOP之前，将暂时使用二级代理的方式处理，以规避循环依赖的问题。

# 2022-05-12

## Spring的AbstractApplicationContext.refresh都做了什么

```java
public abstract class AbstractApplicationContext extends DefaultResourceLoader
        implements ConfigurableApplicationContext {
    
        
	@Override
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			StartupStep contextRefresh = this.applicationStartup.start("spring.context.refresh");

			// Prepare this context for refreshing.
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				StartupStep beanPostProcess = this.applicationStartup.start("spring.context.beans.post-process");
				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);
				beanPostProcess.end();

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
				contextRefresh.end();
			}
		}
	}
}
```
![ApplicationContext的refresh方法执行过程](imgs/ApplicationContext的refresh方法执行过程.png)

# 2022-05-13 Spring的事件处理

事件处理基于观察者模式。

Spring定义了Root级的事件ApplicationEvent，所有Spring框架的Event实现，都要基于这个抽象类。
```java
public abstract class ApplicationEvent extends EventObject
```

这个抽象类基于Java的EventObject，包含了一个Object对象source，该对象被transient关键字修饰，表示在进行序列化后，内容丢失。
ApplicationEvent在此之上增加了timestamp字段，用以标记事件发生的时间戳。

此时实现事件的监听有以下几种方法
1. 直接向context上下文注册ApplicationListener接口的实现；
2. 使用@EventListener注解标记事件处理方法；
3. 将实现ApplicationListener接口的实现类注册为Bean，Spring会在初始化结束后进行判断并注册为事件监听器。

使用基于AbstractApplicationContext的publish方法进行消息发送时，Spring源代码如下
```java

protected void publishEvent(Object event, ResolvableType eventType) {
    Assert.notNull(event, "Event must not be null");
    if (logger.isTraceEnabled()) {
        logger.trace("Publishing event in " + getDisplayName() + ": " + event);
    }

    // Decorate event as an ApplicationEvent if necessary
    // 判断消息是否为Spring的ApplicationEvent消息，若不是，则构建PayloadApplicationEvent来处理自定义消息
    ApplicationEvent applicationEvent;
    if (event instanceof ApplicationEvent) {
        applicationEvent = (ApplicationEvent) event;
    }
    else {
        applicationEvent = new PayloadApplicationEvent<Object>(this, event);
        if (eventType == null) {
            eventType = ((PayloadApplicationEvent)applicationEvent).getResolvableType();
        }
    }

    // Multicast right now if possible - or lazily once the multicaster is initialized
    // Spring初始化过程中，会将earlyApplicationEvents初始化，
    // 此集合不为空，表示当前正在进行初始化，缓存当前事件消息，至multicaster初始化结束后再发布
    if (this.earlyApplicationEvents != null) {
        this.earlyApplicationEvents.add(applicationEvent);
    }
    else {
        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
    }

    // Publish event via parent context as well...
    // 尝试向父级Context发布事件
    if (this.parent != null) {
        if (this.parent instanceof AbstractApplicationContext) {
            ((AbstractApplicationContext) this.parent).publishEvent(event, eventType);
        }
        else {
            this.parent.publishEvent(event);
        }
    }
}

```
Spring默认使用SimpleApplicationEventMulticaster进行消息的广播发布，相关的事件广播代码如下：
```java

public void multicastEvent(final ApplicationEvent event, ResolvableType eventType) {
    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
    for (final ApplicationListener<?> listener : getApplicationListeners(event, type)) {
        Executor executor = getTaskExecutor();
        if (executor != null) {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    invokeListener(listener, event);
                }
            });
        }
        else {
            invokeListener(listener, event);
        }
    }
}

```
根据eventType，从预先注册的Listener中查找符合的监听器。
循环遍历进行事件消息的通知，若当前广播支持异步，则通过Executor进行异步处理，否则同步执行listener中定义的方法。

# 2022-05-13 
参考观察者模式，结合Spring的事件广播机制，编写相应的Demo代码（omega-demo）。

定义根事件类OmegaEvent，定义监听器抽象类OmegaEventListener。

由于需要在Listener的子类上通过泛型对OmegaEvent的子类进行处理，封装GenericTypeUtil工具类，获取Listener实际监听的OmegaEvent实现。
在MultiCaster广播器中，维护了事件Class和监听器列表的注册表，广播事件时，可以更快速的定位监听器列表并进行监听事件处理。

# 2022-05-24
处理针对@Autowired的依赖分析。参考Spring，主要分析三种场景：
1. 通过构造方法注入的，关于构造方法的选择规则如下：
   1. 当该类仅存在一个构造方法时，自动使用该构造方法并获取其依赖列表
   2. 优先获取定义的使用了@Autowired注解的构造方法，同时若类中存在多个@Autowired的构造方法，将抛出异常；
   3. 无@Autowired注解的构造方法时，尝试获取无参数构造方法；
2. 通过Set方法注入的
3. 通过字段注入的

通过获取这些依赖信息，将其扩充至BeanDefinition中，以备初始化时进行处理。

## 关于循环依赖
目前尚未实现循环依赖的检查工作。 
Spring的循环依赖默认不被支持，需要使用```spring.main.allow-circular-references = true```这项配置，打开循环依赖的支持。
循环依赖通过二级缓存进行解决，同时为了解决AOP的动态代理生成的新实例，又引入了三级缓存。

但这种场景仅能支持常规的循环依赖问题，对于Spring建议的通过构造方法注入这种场景，依然无法避免循环依赖导致的问题，将抛出异常并终止执行。


# 2022-05-25
## 关于Spring的AbstractBeanFactory中doGetBean方法的代码解析
```java
    @SuppressWarnings("unchecked")
    protected <T> T doGetBean(
			String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)
			throws BeansException {

        // 前缀切换
        // Spring对Factory的BeanName进行了处理，当使用BeanFactory的Name获取Bean时，
        // 实际得到的是BeanFactory对象中的getBean方法获取到的Bean对象；若希望获取BeanFactory实例本身，则使用&BeanName的方式获取。
        // 见BeanFactory.FACTORY_BEAN_PREFIX

        String beanName = transformedBeanName(name);
        Object beanInstance;
    
        // Eagerly check singleton cache for manually registered singletons.
        // 实际调用到DefaultSingletonBeanRegistry类的getSingleton方法。
        // 该方法尝试在缓存中获取Bean对应的原始对象（Return the (raw) singleton object registered under the given name.）
        Object sharedInstance = getSingleton(beanName);
        if (sharedInstance != null && args == null) {
            if (logger.isTraceEnabled()) {
                if (isSingletonCurrentlyInCreation(beanName)) {
                    logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
                            "' that is not fully initialized yet - a consequence of a circular reference");
                }
                else {
                    logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
                }
            }
            // 若该原始对象存在，则尝试获取它的实际对象。
            // 当该实例为Bean时，返回它本身，若为FactoryBean，则调用工厂方法创建出实际的Bean对象
            // (Get the object for the given bean instance,  either the bean instance itself or its created object in case of a FactoryBean.)
            beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, null);
        }
    
        else {
            
            // 若未从缓存中找到该对象，则尝试创建该对象
            // 首先检查该对象正在（当前线程中）创建，若是，则表示出现了循环引用
            // 检查的原理是Spring将当前线程正在创建的对象写入ThreadLocal中，检查时会判断Set中是否包含当前BeanName
        
            // Fail if we're already creating this bean instance:
            // We're assumably within a circular reference.
            if (isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }
    
            // Check if bean definition exists in this factory.
            BeanFactory parentBeanFactory = getParentBeanFactory();
            if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
                // 尝试从父级工厂中获取当前Bean的BeanDefinition。
                // 若存在父级工厂且未找到当前Bean的BeanDefinition，
                // 则有可能该Bean使用了别名，首先尝试获取Bean的原始名称，之后再尝试获取Bean
        
                // Not found -> check parent.
                String nameToLookup = originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                            nameToLookup, requiredType, args, typeCheckOnly);
                }
                else if (args != null) {
                    // Delegation to parent with explicit args.
                    return (T) parentBeanFactory.getBean(nameToLookup, args);
                }
                else if (requiredType != null) {
                    // No args -> delegate to standard getBean method.
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }
                else {
                    return (T) parentBeanFactory.getBean(nameToLookup);
                }
            }
            // 若当前方法不只是进行类型检查，而是实际获取对象，则将该Bean标记为已创建（或正要被创建）
            if (!typeCheckOnly) {
                markBeanAsCreated(beanName);
            }
            
            // 通过StartupStep对象，标记操作步骤的启动、通过Tag标记执行阶段以及结束过程
            // 结合Spring的事件机制，可以将过程广播以备其它监听器使用。
            // 但在当前代码中，使用了DefaultApplicationStartup，并未执行任何操作（no op）
            StartupStep beanCreation = this.applicationStartup.start("spring.beans.instantiate")
                    .tag("beanName", name);
            try {
                if (requiredType != null) {
                    beanCreation.tag("beanType", requiredType::toString);
                }
                RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
                checkMergedBeanDefinition(mbd, beanName, args);
    
                // Guarantee initialization of beans that the current bean depends on.
                String[] dependsOn = mbd.getDependsOn();
                // 遍历当前Bean通过@DependsOn注解依赖的其它Bean实例，同时进行循环依赖检查。
                if (dependsOn != null) {
                    for (String dep : dependsOn) {
                        if (isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                    "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                        }
                        // 此处维护两个Map，分别是当前Bean及其待注入的dependentBeanName的Map<beanName, Set<dependentBeanName>>;
                        // 另一个是被依赖的dependentBeanName及其上级对象的Map<dependentBeanName, Set<beanName>>
                        // 之所以这样操作，除了标记当前Bean与注入Bean的关系，同时标记出被注入的Bean同时都被哪些Bean所使用
                        // 由此，当dependentBeanName执行destroy时，会同时将使用它的Bean一起destroy掉
                        registerDependentBean(dep, beanName);
                        try {
                            getBean(dep);
                        }
                        // 尝试获取依赖Bean，若不存在，抛出NoSuchBeanDefinitionException
                        catch (NoSuchBeanDefinitionException ex) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                    "'" + beanName + "' depends on missing bean '" + dep + "'", ex);
                        }
                    }
                }
    
                // 执行Bean的实际创建操作，根据其作用域，执行单例对象创建、原型对象创建或其它作用域对应的创建操作
                // Create bean instance.
                if (mbd.isSingleton()) {
                    // 调用父类DefaultSingletonBeanRegistry.getSingleton(String, ObjectFactory<?>)方法
                    // 同时生成ObjectFactory的匿名类，用于创建Bean实例
                    sharedInstance = getSingleton(beanName, () -> {
                        try {
                            // 本方法实际调用子类AbstractAutowireCapableBeanFactory中实现的方法
                            return createBean(beanName, mbd, args);
                        }
                        catch (BeansException ex) {
                            // Explicitly remove instance from singleton cache: It might have been put there
                            // eagerly by the creation process, to allow for circular reference resolution.
                            // Also remove any beans that received a temporary reference to the bean.
                            destroySingleton(beanName);
                            throw ex;
                        }
                    });
                    // 由于拿到的sharedInstance可能是对象本身或是工厂Bean，
                    // 此处进行转换，若为工厂方法，则调用其创建对象的方法生成对象，否则返回Bean本身
                    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }
    
                else if (mbd.isPrototype()) {
                    // It's a prototype -> create a new instance.
                    Object prototypeInstance = null;
                    try {
                        beforePrototypeCreation(beanName);
                        prototypeInstance = createBean(beanName, mbd, args);
                    }
                    finally {
                        afterPrototypeCreation(beanName);
                    }
                    beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                }
    
                else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException("No scope name defined for bean '" + beanName + "'");
                    }
                    Scope scope = this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                    }
                    try {
                        Object scopedInstance = scope.get(beanName, () -> {
                            beforePrototypeCreation(beanName);
                            try {
                                return createBean(beanName, mbd, args);
                            }
                            finally {
                                afterPrototypeCreation(beanName);
                            }
                        });
                        beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    }
                    catch (IllegalStateException ex) {
                        throw new ScopeNotActiveException(beanName, scopeName, ex);
                    }
                }
            }
            catch (BeansException ex) {
                beanCreation.tag("exception", ex.getClass().toString());
                beanCreation.tag("message", String.valueOf(ex.getMessage()));
                cleanupAfterBeanCreationFailure(beanName);
                throw ex;
            }
            finally {
                beanCreation.end();
            }
        }
    
        return adaptBeanInstance(name, beanInstance, requiredType);
    }

```

## 关于Spring的DefaultSingletonBeanRegistry中getSingleton方法的代码解析
```java
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        // Quick check for existing instance without full singleton lock
        // 尝试从一级缓存中获取对象实例
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
            // 一级缓存未找到对象实例，且对象处于创建过程中，则尝试去二级缓存获取
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null && allowEarlyReference) {
                synchronized (this.singletonObjects) {
                    // Consistent creation of early reference within full singleton lock
                    // 二级缓存不存在，则进行加锁，且在得到锁之后重新从一级缓存开始尝试获取对象
                    // 因为得到锁之后，有可能由于之前持有锁的线程已经创建过该对象，所以需要重新尝试逐层获取
                    singletonObject = this.singletonObjects.get(beanName);
                    if (singletonObject == null) {
                        singletonObject = this.earlySingletonObjects.get(beanName);
                        if (singletonObject == null) {
                            ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                            if (singletonFactory != null) {
                                // 通过Bean工厂创建对象，并将其放入二级缓存
                                singletonObject = singletonFactory.getObject();
                                this.earlySingletonObjects.put(beanName, singletonObject);
                                this.singletonFactories.remove(beanName);
                            }
                        }
                    }
                }
            }
        }
        return singletonObject;
    }
```

# 关于Spring的AbstractAutowireCapableBeanFactory中doCreateBean方法的代码解析
```java
    // 实际创建Bean的操作， 此时Bean的预创建工作已经完成，如postProcessBeforeInstantiation的检查等
    protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
            throws BeanCreationException {
    
        // Instantiate the bean.
        BeanWrapper instanceWrapper = null;
        // 若Bean为单例模式，则首先尝试将Bean从factoryBean实例缓存中清除
        if (mbd.isSingleton()) {
            instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
        }
        // 执行实际的Bean创建工作，根据Bean配置的策略，可能调用工厂方法，构造方法注入或是简单的实例化
        if (instanceWrapper == null) {
            instanceWrapper = createBeanInstance(beanName, mbd, args);
        }
        Object bean = instanceWrapper.getWrappedInstance();
        Class<?> beanType = instanceWrapper.getWrappedClass();
        if (beanType != NullBean.class) {
            mbd.resolvedTargetType = beanType;
        }
    
        // Allow post-processors to modify the merged bean definition.
        // MergedBeanDefinitionPostProcessors的后置处理
        synchronized (mbd.postProcessingLock) {
            if (!mbd.postProcessed) {
                try {
                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                            "Post-processing of merged bean definition failed", ex);
                }
                mbd.postProcessed = true;
            }
        }
    
        // Eagerly cache singletons to be able to resolve circular references
        // even when triggered by lifecycle interfaces like BeanFactoryAware.
        // 构造一个工厂Bean，并将其置入三级缓存
        boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
                isSingletonCurrentlyInCreation(beanName));
        if (earlySingletonExposure) {
            if (logger.isTraceEnabled()) {
                logger.trace("Eagerly caching bean '" + beanName +
                        "' to allow for resolving potential circular references");
            }
            // 此处将创建的工厂Bean放至三级缓存，当执行工厂Bean的对象创建时
            // getEarlyBeanReference方法会根据当前的bean实例，判断是否需要创建代理对象
            // 若需要，则创建代理对象，将代理对象添加至二级缓存，否则返回Bean本身
            addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
        }
    
        // Initialize the bean instance.
        Object exposedObject = bean;
        try {
            // 填充对象属性
            populateBean(beanName, mbd, instanceWrapper);
            // 执行工厂方法回调及PostProcessor相关操作
            exposedObject = initializeBean(beanName, exposedObject, mbd);
        }
        catch (Throwable ex) {
            if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
                throw (BeanCreationException) ex;
            }
            else {
                throw new BeanCreationException(
                        mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);
            }
        }
    
        if (earlySingletonExposure) {
            Object earlySingletonReference = getSingleton(beanName, false);
            if (earlySingletonReference != null) {
                if (exposedObject == bean) {
                    exposedObject = earlySingletonReference;
                }
                else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
                    String[] dependentBeans = getDependentBeans(beanName);
                    Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
                    for (String dependentBean : dependentBeans) {
                        if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                            actualDependentBeans.add(dependentBean);
                        }
                    }
                    if (!actualDependentBeans.isEmpty()) {
                        throw new BeanCurrentlyInCreationException(beanName,
                                "Bean with name '" + beanName + "' has been injected into other beans [" +
                                StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                                "] in its raw version as part of a circular reference, but has eventually been " +
                                "wrapped. This means that said other beans do not use the final version of the " +
                                "bean. This is often the result of over-eager type matching - consider using " +
                                "'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.");
                    }
                }
            }
        }
    
        // Register bean as disposable.
        try {
            registerDisposableBeanIfNecessary(beanName, bean, mbd);
        }
        catch (BeanDefinitionValidationException ex) {
            throw new BeanCreationException(
                    mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
        }
    
        return exposedObject;
    }


```
## Spring获取及创建Bean的过程
![Spring获取及创建Bean的过程](imgs/flowOfSpringBeanInitializing.png)
